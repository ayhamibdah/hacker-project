Exercise 0 ‚Äî testShell00
# Start clean
mkdir -p ex0 && cd ex0

# Create exactly 40 bytes (all zeros) and set perms r-- r-x r-x  => 0455
truncate -s 40 testShell00
chmod 455 testShell00
touch -t 202406012047 testShell00
# (Optional) verify
ls -l

# Package for submission
tar -cf testShell00.tar testShell00
**************************************************************************************************************************************************************************

**************************************************************************************************************************************************************************

**************************************************************************************************************************************************************************


Exercise 1 ‚Äî ‚ÄúOh yeah, mooore‚Ä¶‚Äù
# Fresh dir
cd ..; rm -rf ex1; mkdir ex1; cd ex1

# test0  -> drwx--xr-x  => 0715
mkdir -m 715 test0

# test1  -> -rwx--xr-- size 4 => 0714
printf 'data' > test1
chmod 714 test1

# test2  -> dr-x---r--  => 0504
mkdir -m 504 test2

# test3/test5 -> hard links to same inode, perms -r-----r--, size 1, link count 2 => 0404
printf 'a' > test3
chmod 404 test3
ln test3 test5   # creates second hard link (now both show "2" in link count)

# test4 -> -rw-r---x size 2 => 0641
printf 'hi' > test4
chmod 641 test4

# test6 -> symlink -> test0
ln -s test0 test6

touch -t 202406012047 test0
touch -t 202406012146 test1
touch -t 202406012245 test2
touch -t 202406012344 test3
touch -t 202406012343 test4
# test5 inherits test3 timestamp (hard link)
touch -h -t 202406012220 test6   # symlink

# (Optional) verify
ls -l

# Package for submission
tar -cf ex1.tar *
**************************************************************************************************************************************************************************

**************************************************************************************************************************************************************************

**************************************************************************************************************************************************************************
Exercise 2 ‚Äî midLS
# Fresh dir
cd ..; rm -rf ex2; mkdir ex2; cd ex2

# Create the script file
nano midLS >> "ls -t -m -p"
chmod +x midLS

# (Optional) test:
# ./midLS
**************************************************************************************************************************************************************************

**************************************************************************************************************************************************************************

**************************************************************************************************************************************************************************
# Fresh dir
cd ..; rm -rf ex3; mkdir ex3; cd ex3

# Create the exact filename with special chars and write exactly two bytes: 4 and 2
# (printf without a newline)
printf 42 > "\"\\?\$*'MaRViN'*\$?\\\""

# (Optional) verify size (should be 2 bytes) and name rendering
ls -lRa *MaRV* | cat -A

**************************************************************************************************************************************************************************

**************************************************************************************************************************************************************************

**************************************************************************************************************************************************************************
#!/bin/bash
# git_commit.sh - Display the last 5 commit IDs using grep

git log | grep "^commit" | head -n 5 | awk '{print $2}'
**************************************************************************************************************************************************************************

**************************************************************************************************************************************************************************

**************************************************************************************************************************************************************************  GNU nano 8.1                                        git_ignore.sh                                                  
#!/bin/bash

# This script lists all files ignored by the Git repository.

# The 'git ls-files' command is used with the following options:
# --others: Lists untracked files.
# --ignored: Includes files that are explicitly ignored by Git (e.g., via .gitignore).
# --exclude-standard: Applies standard Git exclusion rules (from .gitignore, .git/info/exclude, and global excludes).

git ls-files --others --ignored --exclude-standard

**************************************************************************************************************************************************************************

**************************************************************************************************************************************************************************

************************************************************************************************************************************************************************** 
find . -name "*.sh" | sed -E 's/(\.sh)*$//'

1. find . -name "*.sh"

find .: Search recursively from the current directory.

-name "*.sh": Match files whose names end in .sh.

2. | sed -E 's/(\.sh)*$//'

This takes the output of find and processes each line with sed.

-E: Enable extended regular expressions, so you don't have to escape () and + excessively.

's/(\.sh)*$//': This is the substitution pattern.

Let‚Äôs break down the pattern s/(\.sh)*$//:

s/.../.../: Basic structure of a substitution in sed.

(\.sh)*: A group that matches zero or more occurrences of .sh.

\. matches a literal dot.

sh matches the characters "sh".

* means zero or more repetitions of that group.

$: Anchors the match to the end of the line.

'' (empty string as replacement): Means we're removing the .sh (or repeated .sh) at the end.



**************************************************************************************************************************************************************************


find . \( -name "*~" -o -name "#*#" \) -print -delete

üîç Breakdown

    find .:
    Start the search in the current directory (.) and all subdirectories.

    \( ... \):
    Grouping of conditions (parentheses are escaped with backslashes to avoid shell interpretation).

    -name "*~":
    Match files whose names end with a tilde ~.
    These are typically backup files created by editors like vim or nano.
    Example: file.txt~

    -o:
    Logical OR ‚Äî either the previous -name "*~" or the next condition.

    -name "#*#":
    Match files that start and end with a hash #.
    These are temporary or autosave files often created by emacs.
    Example: #file.txt#

    -print:
    Print the path of each file found.
    This helps verify which files are being targeted before deletion.

    -delete:
    Actually delete the files that match the conditions.

**************************************************************************************************************************************************************************

**************************************************************************************************************************************************************************

find . \( -type f -o -type d \) | wc -l

find .: Start searching from the current directory.

-type f: Match regular files.

-o: OR

-type d: Match directories.

wc -l: Count the number of lines (i.e., number of matches).



